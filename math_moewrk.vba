#!/bin/basik
// RULES OF MATHEMOE

fn comment(stoopak : i32) -> i32 {
const dunnobuild = r##How it works?
It's simple, all you need to do is iterate through the array, checking if its elements are in order. Any element that isn't in order you pull out, in other words, you send it to Gulag.

Step-by-step example
(1 2 5 3 5 7) -> (1 2 5 3 5 7) Here the algorithm stores the first of element of the array
(1 2 5 3 5 7) -> (1 2 5 3 5 7) Now it will compare the stored element with the second one, if this is bigger than the stored, it replaces the stored element by this
(1 2 5 3 5 7) -> (1 2 5 3 5 7) Repeats step 2
(1 2 5 3 5 7) -> (1 2 5 5 7) Since the 4th element is smaller than the 3rd one, the 4th element will be eliminated.
(1 2 5 5 7) -> (1 2 5 5 7) Equal elements are preserved
(1 2 5 5 7) Ordered array!##
}

fn main(mut Vec<i32> : biomasses) -> ! { // I shall .now() reval my i1 true IFC multipart || In othwr weirds, they 2lld uss 2 brass some constants without code & goto wrk.
let usin : Vec<i32> = biomasses.into_iter().scan(biomasses[0], |akkun, &&xxx| {
let www =  xxx.overflowing_abs() + akkun.overflowing_abs() );
if     ( www > xxx.overflowing_shl(1)) { return(); }                   // SoyGo is soy mun fuch.
elseif ( www = xxx.overflowing_shl(1)) { return(akkun); }              // Keck, i wonder wut eqre for cond would b.
else                                   { akkun = xxx; return(akkun); } // Ate ulong 1.
})                                                                     // coding async js
.collect(Vec<_>);                                                      // подшейте его
die(biomasses.last());
}
